# CS-350
### For this README we were tasked to select two project artifacts from this course that I think best reflected my talents. The artifacts that I chose were milestone two where we were working with the UART and GPIO drivers to turn the on board LEDs ON or OFF depending on what the user typed and our final project, where we tied everything we learned throughout the course together.
## Module Two Milestone
### Our overall goal was to control the LEDs on the board, using a state machine to turn on an LED when the user types ON and off when the user types OFF.
### I particularly did troubleshooting extremely well. This was still very early into the course, only being the third week and we were still using a new program and interface that we had really only used once, in the previous weeks getting the board up and running. Being able to figure out what was going on and what was actually going wrong was a huge boost to my initial confidence to boost my comfortability with the resources we were using.
### I managed to not initially read that we were to use a state machine within our code, so I could very easily improve by adding that into the code. But I am glad I was able to get it to work regardless.
### While the very early stages, this added the beginning stages of using the tools of the TI SimpleLink WiFi CC3220S and Code Composer Studio. In addition, I have more resources in that or using UART and GPIO drivers to control the board.
### If I were to go into a future systems engineering role, I could very easily end up using all of these skills into future work projects. As all of these are farily early skills, they will likely be expanded upon, but the more advanced skills still build upon these early skills.
### My code is maintainable because is would be easy for someone with the knowledge to look at my code and be able to debug or take over and add their own code to it. It is readable by adding in line comments to help explain what the code is doing as well as avoiding complex syntax where able. The code is adaptable as it avoids specific parameters where able, allowing for easier future use of the same code, with very few if any changes.
## Final Project
### For this final project we were tasked with using our previous knowledge and skills to create a mock thermostat using the temperature sensor on the board to read the room temperature, compare the room temperature to the set temperature, have the buttons on the side to adjust the set temperature, and turn the light on or off if the heat is on or off.
### I am proud of how well I was able to get everything to implement with one another without causing errors. In this specific project we were given a decent amount of starter code to run some of the aspects that we had not interacted with yet, so being able to get all of this code to paste into the base file impressed myself.
### My confidence could improve greatly as well as cleaning up some of my code. I wish my confidence had increased more throughout the course, but even going into this project I was very much doubting how well I could do with it. While I am proud of how well I did with it, I do believe I could have done better and made it much more streamlined. For my code being cleaner, there was a bit of the guideline commented code that was initially provide that I forgot to get rid of, even though I provided the functionality in a different location.
### There are so many tools and resources that will be staying with me throughout my future careers. Again getting to use all of the drivers that were a part of this, and the board itself. Even having some extra comfortability with the software gives me a starting point for a board that is pretty widely used in companies currently.
### For skills, I mostly mentioned it previously, but the ability to use the specific drivers are very important to bring with me in the future. These drivers would provide very useful baseline skills for future projects within a systems engineering role. In addition, I have gained more coding knowledge, which while not directly relatable language to language, can still be adapted somewhat.
### My code is maintainable because is would be easy for someone with the knowledge to look at my code and be able to debug or take over and add their own code to it. It is readable by adding in line comments to help explain what the code is doing as well as avoiding complex syntax where able. The code is adaptable as it avoids specific parameters where able, allowing for easier future use of the same code, with very few if any changes.
